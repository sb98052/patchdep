From: Andrew Morton <akpm@linux-foundation.org>

Cc: "Eric W. Biederman" <ebiederm@xmission.com>
Cc: "Serge E. Hallyn" <serue@us.ibm.com>
Cc: Balbir Singh <balbir@in.ibm.com>
Cc: Dave Hansen <haveblue@us.ibm.com>
Cc: Herbert Poetzl <herbert@13thfloor.at>
Cc: Kirill Korotaev <dev@openvz.org>
Cc: Paul Jackson <pj@sgi.com>
Cc: Paul Menage <menage@google.com>
Cc: Srivatsa Vaddagiri <vatsa@in.ibm.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
---

 kernel/container.c |   28 ++++++++++++----------------
 1 file changed, 12 insertions(+), 16 deletions(-)

diff -puN kernel/container.c~containersv10-add-tasks-file-interface-fix kernel/container.c
--- a/kernel/container.c~containersv10-add-tasks-file-interface-fix
+++ a/kernel/container.c
@@ -680,7 +680,6 @@ static void get_first_subsys(const struc
  * Call holding container_mutex.  May take task_lock of
  * the task 'pid' during call.
  */
-
 static int attach_task(struct container *cont, struct task_struct *tsk)
 {
 	int retval = 0;
@@ -689,8 +688,8 @@ static int attach_task(struct container 
 	struct css_group *cg = &tsk->containers;
 	struct containerfs_root *root = cont->root;
 	int i;
-
 	int subsys_id;
+
 	get_first_subsys(cont, NULL, &subsys_id);
 
 	/* Nothing to do if the task is already in that container */
@@ -740,9 +739,7 @@ static int attach_task(struct container 
 /*
  * Attach task with pid 'pid' to container 'cont'. Call with
  * container_mutex, may take task_lock of task
- *
  */
-
 static int attach_task_by_pid(struct container *cont, char *pidbuf)
 {
 	pid_t pid;
@@ -799,7 +796,8 @@ static ssize_t container_common_file_wri
 		return -E2BIG;
 
 	/* +1 for nul-terminator */
-	if ((buffer = kmalloc(nbytes + 1, GFP_KERNEL)) == 0)
+	buffer = kmalloc(nbytes + 1, GFP_KERNEL);
+	if (buffer == NULL)
 		return -ENOMEM;
 
 	if (copy_from_user(buffer, userbuf, nbytes)) {
@@ -1030,16 +1028,16 @@ int container_add_files(struct container
  * time-efficient but less space-efficient with more linked lists
  * running through each container and the css_group structures that
  * referenced it. Must be called with tasklist_lock held for read or
- * write or in an rcu critical section. */
-
+ * write or in an rcu critical section.
+ */
 int __container_task_count(const struct container *cont)
 {
 	int count = 0;
 	struct task_struct *g, *p;
 	struct container_subsys_state *css;
 	int subsys_id;
-	get_first_subsys(cont, &css, &subsys_id);
 
+	get_first_subsys(cont, &css, &subsys_id);
 	do_each_thread(g, p) {
 		if (task_subsys_state(p, subsys_id) == css)
 			count ++;
@@ -1061,9 +1059,6 @@ int __container_task_count(const struct 
  * be freed by release() when the file is closed.  The array is used
  * to sprintf the PIDs and then used by read().
  */
-
-/* containers_tasks_read array */
-
 struct ctr_struct {
 	char *buf;
 	int bufsz;
@@ -1082,9 +1077,9 @@ static int pid_array_load(pid_t *pidarra
 	struct task_struct *g, *p;
 	struct container_subsys_state *css;
 	int subsys_id;
+
 	get_first_subsys(cont, &css, &subsys_id);
 	rcu_read_lock();
-
 	do_each_thread(g, p) {
 		if (task_subsys_state(p, subsys_id) == css) {
 			pidarray[n++] = pid_nr(task_pid(p));
@@ -1179,10 +1174,11 @@ static ssize_t container_tasks_read(stru
 {
 	struct ctr_struct *ctr = file->private_data;
 
-        return simple_read_from_buffer(buf, nbytes, ppos, ctr->buf, ctr->bufsz);
+	return simple_read_from_buffer(buf, nbytes, ppos, ctr->buf, ctr->bufsz);
 }
 
-static int container_tasks_release(struct inode *unused_inode, struct file *file)
+static int container_tasks_release(struct inode *unused_inode,
+					struct file *file)
 {
 	struct ctr_struct *ctr;
 
@@ -1197,7 +1193,6 @@ static int container_tasks_release(struc
 /*
  * for the common functions, 'private' gives the type of file
  */
-
 static struct cftype cft_tasks = {
 	.name = "tasks",
 	.open = container_tasks_open,
@@ -1215,7 +1210,8 @@ static int container_populate_dir(struct
 	/* First clear out any existing files */
 	container_clear_directory(cont->dentry);
 
-	if ((err = container_add_file(cont, &cft_tasks)) < 0)
+	err = container_add_file(cont, &cft_tasks);
+	if (err < 0)
 		return err;
 
 	for_each_subsys(cont->root, ss) {
_
