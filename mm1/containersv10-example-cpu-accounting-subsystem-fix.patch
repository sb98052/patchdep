From: Andrew Morton <akpm@linux-foundation.org>

Cc: "Eric W. Biederman" <ebiederm@xmission.com>
Cc: "Serge E. Hallyn" <serue@us.ibm.com>
Cc: Balbir Singh <balbir@in.ibm.com>
Cc: Dave Hansen <haveblue@us.ibm.com>
Cc: Herbert Poetzl <herbert@13thfloor.at>
Cc: Kirill Korotaev <dev@openvz.org>
Cc: Paul Jackson <pj@sgi.com>
Cc: Paul Menage <menage@google.com>
Cc: Srivatsa Vaddagiri <vatsa@in.ibm.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
---

 kernel/cpu_acct.c |   21 +++++++++++----------
 1 file changed, 11 insertions(+), 10 deletions(-)

diff -puN kernel/cpu_acct.c~containersv10-example-cpu-accounting-subsystem-fix kernel/cpu_acct.c
--- a/kernel/cpu_acct.c~containersv10-example-cpu-accounting-subsystem-fix
+++ a/kernel/cpu_acct.c
@@ -16,6 +16,8 @@
 #include <linux/module.h>
 #include <linux/container.h>
 #include <linux/fs.h>
+#include <linux/rcupdate.h>
+
 #include <asm/div64.h>
 
 struct cpuacct {
@@ -50,7 +52,8 @@ static inline struct cpuacct *task_ca(st
 
 #define INTERVAL (HZ * 10)
 
-static inline u64 next_interval_boundary(u64 now) {
+static inline u64 next_interval_boundary(u64 now)
+{
 	/* calculate the next interval boundary beyond the
 	 * current time */
 	do_div(now, INTERVAL);
@@ -60,6 +63,7 @@ static inline u64 next_interval_boundary
 static int cpuacct_create(struct container_subsys *ss, struct container *cont)
 {
 	struct cpuacct *ca = kzalloc(sizeof(*ca), GFP_KERNEL);
+
 	if (!ca)
 		return -ENOMEM;
 	spin_lock_init(&ca->lock);
@@ -78,6 +82,7 @@ static void cpuacct_destroy(struct conta
 static void cpuusage_update(struct cpuacct *ca)
 {
 	u64 now = get_jiffies_64();
+
 	/* If we're not due for an update, return */
 	if (ca->next_interval_check > now)
 		return;
@@ -91,18 +96,16 @@ static void cpuusage_update(struct cpuac
 	} else {
 		/* If a steal takes the last interval time negative,
 		 * then we just ignore it */
-		if ((s64)ca->current_interval_time > 0) {
+		if ((s64)ca->current_interval_time > 0)
 			ca->last_interval_time = ca->current_interval_time;
-		} else {
+		else
 			ca->last_interval_time = 0;
-		}
 		ca->next_interval_check += INTERVAL;
 	}
 	ca->current_interval_time = 0;
 }
 
-static u64 cpuusage_read(struct container *cont,
-			 struct cftype *cft)
+static u64 cpuusage_read(struct container *cont, struct cftype *cft)
 {
 	struct cpuacct *ca = container_ca(cont);
 	u64 time;
@@ -118,8 +121,7 @@ static u64 cpuusage_read(struct containe
 	return time;
 }
 
-static u64 load_read(struct container *cont,
-		     struct cftype *cft)
+static u64 load_read(struct container *cont, struct cftype *cft)
 {
 	struct cpuacct *ca = container_ca(cont);
 	u64 time;
@@ -149,8 +151,7 @@ static struct cftype files[] = {
 	}
 };
 
-static int cpuacct_populate(struct container_subsys *ss,
-			    struct container *cont)
+static int cpuacct_populate(struct container_subsys *ss, struct container *cont)
 {
 	return container_add_files(cont, files, ARRAY_SIZE(files));
 }
_
